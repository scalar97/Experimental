The following repository contains personal implementation of the 'Python-Programming-Funcdation' course I took on Udacity.
This ReadMe file contains personal notes I took as I while I was taking the course. 

** Modules

- the similarity between webbrowser and turtle is that they are both modules

** Functions vs Methods

- the difference between _webbrowser.open()_ and _turtle.Turle()_ is 
  that *open()* is a function withing he webbwoser module. 
  A function is a block of code that is *NOT bound* to any specific class or object.
  *Turtle()* on the other hand is a class within the turtle module.
  This class will have methods that will be bound to it and accessed by explicitly
  creating an instance of this class.
  
  _When the object is instantiated, the CPU allocates memory to the newly created object._
  
- Also When webbrowser.open is called, the body of the open() function is executed,
  meanwhile when *turtle.Turtle()* is called, it is its *__init__()* method body that is executed

** Nested Packages and modules

To access nested modules, the dot is used as opposed to the slash
e.g. to access *../twilio/rest/__init__.py*
#+begin_src python :session 
import twilio.rest
#+end_src

this automatically gives acces to all the contents inside *__init__.py*
e.g 
#+begin_src python :session 
baz = TwilioRestClient(spam, eggs)
#+end_src

The following is also valid.

#+begin_src python :session
from twilio import rest
baz = rest.TwilioRestClient(foo,spam)
#+end_src

** Class definition and instatiation
- It is good practice to define your classes in one file
  Then import them in another for use.

- When the self keyword is taken out from a variable inside a method, 
  that variable gets changed from an instance attribute or instance varuable to 
  a local variable inside that method. 
  The same thing apply for functions that do not take self as their first argument.
  these are usually helper functions to instance methods. or object methods.

** Class variables
- class variables are variables that are shared among instances.
  example in the media.Movie() class, if there is a new variable called valid ratings
  it would not make sens for toy_story to have its own attribute called 

#+begin_src python :session
toy_story.VALID_RATINGS =tuple()
#and for the avatar movie to have an attribute called
avatar.VALID_RATINGS=tuple()
#+end_src

  the valid_ratings set() is a good candidate for a class variable as it is the same ressource among
  all instances.

	- To access a class variable, the class name has to be used.

#+begin_src python :results output export
class Movie(object):
	VALID_RATINGS = ("G", "PG", "PG-13", "R")
	def __init__(self,*args, **kwargs):
		pass
# to access the valid ratings
print(Movie.VALID_RATINGS)

#+end_src

#+RESULTS:
: ('G', 'PG', 'PG-13', 'R')

  Notice that the above code is not bound to any object, but the class itself, because
it is a class method.
  And since *VALID_RATINGS is now a constant* it should be all capitals by convention. 
  I also changed the datastrucutre from set to tuple to make the variable /immuatable/.

*** Built-in class variables.

 |---------------+--------------------------------------------------------------+------------------|
 | Variable name | Description                                                  | Return type      |
 |---------------+--------------------------------------------------------------+------------------|
 | /__doc__/     | displays the documentation written at thestart of the class. | string, None     |
 |---------------+--------------------------------------------------------------+------------------|
 | /__name__/    | Displays the name of the class                               | string           |
 |---------------+--------------------------------------------------------------+------------------|
 | /__base__/    | Displays classes from which this class inherits from         | tuple of classes |
 |---------------+--------------------------------------------------------------+------------------|
 | /__module__/  | Displays the name of the module a.k.a file in which this     | String           |
 |               | module was defined                                           |                  |
 |---------------+--------------------------------------------------------------+------------------|

#+begin_src python :results output export
class Movie(object):
	'''This class provides a way to store movie related information'''
	pass

# displaying the class attributes
class_variables = ('Movie.__name__', 'Movie.__doc__', 'Movie.__base__', 'Movie.__module__')
for attribute in class_variables:
	print(attribute,'\t:',eval(attribute))

#+end_src

#+RESULTS:
: Movie.__name__ 	: Movie
: Movie.__doc__ 	: This class provides a way to store movie related information
: Movie.__base__ 	: <class 'object'>
: Movie.__module__ 	: __main__

** Inheritance
Inheritance is when one object uses attributes and methods from another object that make sens for it to have.

e.g
#+begin_src python :session
class Parent(object):
	def __init__(self,last_name, eye_color):
		self.last_name = last_name
		self.eye_color = eye_color

class Child(Parent):
	pass
#+end_src

The code above sets the Child class to use everything currently
defined in the Parent class. 
This is done by *explicitly passing the /Parent/ class as an attribute to the Child class*

The Child class however has varables that are specific to its class.
e.g the child may have a certain number of toys.

#+begin_src python :session
class Child(Parent):
	def __init__(self,last_name, eye_color, number_of_toys):
		pass
#+end_src

To initialise variables of the inherited Child class, The parent constructor has to be invoked.
This is done using the *super()* keyword.
e.g

#+begin_src python :session
class Child(Parent):
	def __init__(self,last_name, eye_color, number_of_toys):
		super().__init__(last_name, eye_color)
		self.number_of_toys = number_of_toys
#+end_src

Notice that the parent constructor is only called with the arguments it has. Not new ones like /number_of_toys/.
As these are specific to the child, *they have to be explicitly initialised inside the Child() class*.
thus:
#+begin_src python :session
self.number_of_toys = number_of_toys
#+end_src

only present in the Child class and *not the Parent() class, Nor passed to it via the super() constructor*.

*** Instatiation

To instantiate noth the Parent and Child, simply pass positional arguments as they are expected in their respective constructor methods.

#+begin_src python :session

# the Parent __init__() expects this in this order
catty_billy = Parent('Billy', 'gray')

#the Child class expects a new attribute number_of_toys
pat_billy = Child('Billy','brown',10)

#+end_src

*IMPORTANT NOTE :* though pat_billy inherits from catty_billy, does not mean that they have to have the same value for the eye_colors.

In real life, people who uses inheritance may difine it in term of values because it may make sens in that case.
However in coding perspective inheritance refers to the attributes that the Parent has which make sens for inherited children 
clas to acquire. if a parent has a surname, che child should have it too if this later inherits from the parent.

Inheritance generaly refers to the *shared attributes* as opposed to *similar values*.
e.g the parent has an eye_color attribute and so is the child.
the parent's eye color value may be gray but the kid's eye color's value may not.

Usually these classes make sens to inherit from eachother both in real-life and in code.



