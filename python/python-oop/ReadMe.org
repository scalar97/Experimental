The following repository contains personal implementation of the 'Python-Programming-Funcdation' course I took on Udacity.
This ReadMe file contains personal notes I took as I while I was taking the course. 

* Modules in Python

  Modules in python are any file consisting of python code. this module can define.
  modules, functions, classes..

- the similarity between webbrowser and turtle is that they are both modules


* Packages in Python

  A package is a folder that contain many modules.
  e.g in the folder ./awesome there are three modules:
	- ukulele.py
	- barbeque.py
	- cycing.py
	- surfing.py
  Imagine there is a new file called 'vacation.py' that needs all the files in the folder '/awesome'
  there are few ways they can ba imported.

  1. By Module name (explicitly): this can also be done one line at a time.

#+begin_src python :session
from awesome import ukulele, barbeque, cycling, surfing
#+end_src

  2. All module names at once
#+begin_src python :session
from awesome import *
#+end_src

 3. Module name and their content explicitly : too many lines in my vacations.py already
#+begin_src python :session
from awesome.ukulele import *
from awesome.barbeque import *
from awesome.cycling import *
from awesome.surfing import *
#+end_src

 4. *Using an __init__.py file*
This file combines all the methods you may want to use at once when importing any package.
e.g 

#+begin_src python :session
# __init__.py's content

from awesome.ukulele import *
from awesome.barbeque import *
from awesome.cycling import *
from awesome.surfing import *
#+end_src

Now in vacation.py, simply import /awesome/ and all the code in __init__.py will be added.

#+begin_src python :session
# vacation.py's content

import awesome
...
#+end_src


* Functions vs Methods

- The difference between _webbrowser.open()_ and _turtle.Turle()_ is 
  that *open()* is a function withing he webbwoser module. 
  A function is a block of code that is *NOT bound* to any specific class or object.
  *Turtle()* on the other hand is a class within the turtle module.
  This class will have methods that will be bound to it and accessed by explicitly
  creating an instance of this class.
  
  _When the object is instantiated, the CPU allocates memory to the newly created object._
  
- Also When webbrowser.open is called, the body of the open() function is executed,
  meanwhile when *turtle.Turtle()* is called, it is its *__init__()* method body that is executed


* Nested Packages and modules

To access nested modules, the dot is used as opposed to the slash
e.g. to access *../twilio/rest/__init__.py*
#+begin_src python :session 
import twilio.rest
#+end_src

This automatically gives acces to all the contents inside *__init__.py*
e.g

#+begin_src python :session 
baz = TwilioRestClient(spam, eggs)
#+end_src

The following is also valid.

#+begin_src python :session
from twilio import rest
baz = rest.TwilioRestClient(foo,spam)
#+end_src


* Class definition and instatiation

- It is good practice to define your classes in one file
  Then import them in another for use.

- When the *self* keyword is taken out from a variable inside a method, 
  that variable gets changed from an instance attribute or instance varuable to 
  a local variable inside that method. 
  The /same thing apply for functions that do not take self as their first argument/.
  these are usually helper functions to instance methods. or object methods.


* Class variables

- Class variables are variables that are shared among instances.
  example in the media.Movie() class, if there is a new variable called valid ratings
  it would not make sens for toy_story to have its own attribute called 

#+begin_src python :session
toy_story.VALID_RATINGS =tuple()
#and for the avatar movie to have an attribute called
avatar.VALID_RATINGS=tuple()
#+end_src

  The valid_ratings set() is a good candidate for a class variable as it is the same ressource among all instances.

	- To access a class variable, the class name has to be used.

#+begin_src python :results output export
class Movie(object):
	VALID_RATINGS = ("G", "PG", "PG-13", "R")
	def __init__(self,*args, **kwargs):
		pass
# to access the valid ratings
print(Movie.VALID_RATINGS)

#+end_src

RESULTS:
#+begin_src
('G', 'PG', 'PG-13', 'R')
#+end_src

  Notice that the above code is not bound to any object, but the class itself, because
it is a class method.
  And since *VALID_RATINGS is now a constant* it should be all capitals by convention. 
  I also changed the datastrucutre from set to tuple to make the variable /immuatable/.

** Built-in class variables.

 |---------------+-----------------------------------------------------------------------------+------------------|
 | Variable name | Description                                                                 | Return type      |
 |---------------+-----------------------------------------------------------------------------+------------------|
 | /__doc__/     | displays the documentation written at thestart of the class.                | string, None     |
 |---------------+-----------------------------------------------------------------------------+------------------|
 | /__name__/    | Displays the name of the class                                              | string           |
 |---------------+-----------------------------------------------------------------------------+------------------|
 | /__base__/    | Displays classes from which this class inherits from                        | tuple of classes |
 |---------------+-----------------------------------------------------------------------------+------------------|
 | /__module__/  | Displays the name of the module a.k.a file in which this module was defined | String           |
 |---------------+-----------------------------------------------------------------------------+------------------|

#+begin_src python :results output export
class Movie(object):
	'''This class provides a way to store movie related information'''
	pass

# displaying the class attributes
class_variables = ('Movie.__name__', 'Movie.__doc__', 'Movie.__base__', 'Movie.__module__')
for attribute in class_variables:
	print(attribute,'\t:',eval(attribute))

#+end_src

RESULTS:
#+begin_src 

Movie.__name__ 	: Movie
Movie.__doc__ 	: This class provides a way to store movie related information
Movie.__base__ 	: <class 'object'>
Movie.__module__: __main__
#+end_src


* Inheritance

Inheritance is when one object uses attributes and methods from another object that make sens for it to have.

e.g
#+begin_src python :session
class Parent(object):
	def __init__(self,last_name, eye_color):
		self.last_name = last_name
		self.eye_color = eye_color

class Child(Parent):
	pass
#+end_src

The code above sets the Child class to use everything currently
defined in the Parent class. 
This is done by *explicitly passing the Parent class as an attribute to the Child() class using Child(Parent)*

The Child class however has varables that are specific to its class.
e.g the child may have a certain number of toys.

#+begin_src python :session
class Child(Parent):
	def __init__(self,last_name, eye_color, number_of_toys):
		pass
#+end_src

To initialise variables of the inherited Child class, The parent constructor has to be invoked.
This is done using the *super()* keyword.
e.g

#+begin_src python :session
class Child(Parent):
	def __init__(self,last_name, eye_color, number_of_toys):
		super().__init__(last_name, eye_color)
		self.number_of_toys = number_of_toys
#+end_src

Notice that the parent constructor is only called with the arguments it has. Not new ones like /number_of_toys/.
As these are specific to the child, *they have to be explicitly initialised inside the Child() class*.
thus:
#+begin_src python :session
self.number_of_toys = number_of_toys
#+end_src

Only present in the Child class and *not the Parent() class, Nor passed to it via the super() constructor*.

** Instatiation

To instantiate noth the Parent and Child, simply pass positional arguments as they are expected in their respective constructor methods.

#+begin_src python :session

# the Parent __init__() expects arguments in this order
catty_billy = Parent('Billy', 'gray')

#the Child class expects a new attribute number_of_toys
pat_billy = Child('Billy','brown',10)

#+end_src

*IMPORTANT NOTE :* though pat_billy inherits from catty_billy, does not mean that they have to have the same value for the eye_colors.

In real life, people who uses inheritance may difine it in term of values because it may make sens in that case.
However in coding perspective inheritance refers to the attributes that the Parent has which make sens for inherited children 
clas to acquire. if a parent has a surname, che child should have it too if this later inherits from the parent.

Inheritance generaly refers to the *shared attributes* as opposed to *similar values*.
e.g the parent has an eye_color attribute and so is the child.
the parent's eye color value may be gray but the kid's eye color's value may not.

** Reusing Methods

When a child class inherits from a parent class, it also inherits the methods.

e.g in the parent class

#+begin_src python :session

class Parent(object):
	...
	def show_info(self):
		return f'{self.last_name} has {self.eye_color} eyes.'

#+end_src

The child class does not have this method. but because it inherits it from the parent class, the following produce this output.

#+begin_src python :session

>>>catty_billy.show_info()
'Billy has gray eyes.'
>>>pat_billy.show_info()
'Billy has brown eyes.'
#+end_src

pat_billy does not have the show_info() method but can access it through its inheritance.


** Method overriding

The child class could use the parent show_info() method but this method does not take in account the child specific variables such as the number_of_toys.
To include this, the parent show_info method has to be overriden.

#+begin_src python :session

class Child(Parent):
	...
	def show_info(self):
		return super().show_info()[-1]+ f' and owns {self.number_of_toys} toys.'

>>> catty_billy.show_info()
'Billy has gray eyes.'
>>> pat_billy.show_info()
'Billy has brown eyes and owns 10 toys.'

#+end_src

Notice that the child object gets the super().show_info() method customised to its own attribute.
As the show_info() method returns a string, the children can erform iterable operations to it such as *slicing the trailling dot from the parent show_info() version, using super().show_info()[-1]*.


~ end of the course ~
